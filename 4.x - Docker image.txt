4.1. Что такое image

Docker Image (образ Docker) - это базовый компонент Docker, содержащий все необходимое для запуска контейнера. Образы собираются из слоев (layers), где каждый слой - это набор изменений относительно предыдущего.
Слои Имиджа

    Immutable: Слои доступны только для чтения.
    Экономия Места: При наличии общих слоев для разных образов экономится место на диске.
    Layer Identifier: Уникальный идентификатор, обеспечивающий отслеживание и оптимизацию хранения.

Пример с Nginx

    Загрузка образа Nginx через команду docker pull nginx.
    Просмотр составляющих образа показывает наличие 6 слоев.
    При создании контейнера из образа добавляется еще один слой, доступный для записи.

Работа с Image на Диске

    Сохранение Образа: Используя команду docker save, можно сохранить образ на диск.
    Просмотр Содержимого: Через разархивацию и анализ файлов можем видеть слои и конфигурацию образа.

Файловая Система и Экономия Места

    Overlay File System: В основе работы слоев лежит overlay файловая система, позволяющая эффективно управлять изменениями и объединять слои.
    Эффективное Переиспользование: Общие слои для разных образов и контейнеров позволяют значительно сократить количество используемого места.

Управление Image

    Просмотр Истории Сборки: Команда docker history позволяет увидеть все изменения, внесенные в образ.
    Оценка Использования Диска: Команды типа du показывают, насколько эффективно Docker использует дисковое пространство.


4.2. Работа с image

Основные команды для работы с Docker Images

    Просмотр команд - Введите docker-image help для получения списка команд.
    Исключение - Не будем рассматривать build команду в этом обзоре.

Инспектирование образов

    docker history <image> - Показывает слои образа и команды, использованные при его сборке.
    docker inspect <image> - Выводит подробную информацию об образе, включая ID, метаданные, переменные окружения, объемы и слои.

Импорт и сохранение образов

    docker save <image> - Сохраняет образ в архив.
    docker import <archive> - Создает образ из архива. Используется для переноса образов без реестра.

Работа с реестром

    docker pull <image> - Загружает образ из Docker реестра.
    docker push <image> - Отправляет локальный образ в реестр.

Вывод списка образов и фильтрация

    docker image ls - Показывает список всех локальных образов.
        Фильтрация - Используйте фильтры и форматирование для поиска конкретных образов (например, docker image ls --filter before=<image>).

Управление образами

    Удаление образов:
        docker image rm <image> - Удаляет образ. Если на образ ссылаются запущенные контейнеры, его удаление потребует дополнительного подтверждения или принудительного удаления (--force).
    Обработка "висящих" образов (Dangling Images):
        Висящие образы - это образы без тегов.
        docker image prune - Удаляет все висящие образы.

Примеры и использование

    Смена тега образа через docker tag может приводить к созданию висящих образов.
    Важно регулярно очищать ненужные или старые образы для освобождения места.


4.3. Dockerfile

Введение в Dockerfile

    Dockerfile: текстовый файл с инструкциями для создания образов Docker.
    Пример: образ для приложения на Node.js.
    Инструкции Dockerfile начинаются командой и аргументом.
    Важность оптимизации Dockerfile: минимизация числа слоёв для эффективности.

О контексте построения

    Важность контекста: текущая директория для команды docker build.
    Рекомендация: минимизировать контекст, использовать .dockerignore.

Команды в Dockerfile

    ARG: передача аргументов во время сборки.
    FROM: базовый образ для вашего образа.
    LABEL: мета-информация об образе.
    WORKDIR и USER: настройка рабочей директории и пользователя.
    ADD и COPY: добавление файлов из контекста.
    RUN: выполнение команд в контейнере.
    ENV: установка переменных окружения.
    ENTRYPOINT и CMD: указание команды для выполнения контейнером.

Особые инструкции

    EXPOSE: документация для открытия портов.
    Мультисценарное сборка (multistage build): позволяет оптимизировать сборку, разделяя на несколько этапов.

Работа с ENTRYPOINT и CMD

    Различия между ENTRYPOINT и CMD.
    Как и когда использовать каждую из них для определения команды запуска контейнера.

Практика: создание первого Dockerfile

    Создание Dockerfile для монорепозитория.
    Применение изученных инструкций и лучших практик.


4.4. Создаем свой image

Обзор задачи:
Наша цель - создать Dockerfile для сборки одного из сервисов монорепозитория, содержащего сервисы на NestJS и React. Проект был выбран для демонстрации масштабирования сервисов и взаимодействия между фронтендом и бэкендом в полноценном веб-приложении.

Шаги работы:

    1. Подготовка проекта:
        Удаление директории node_modules (если она существует).
        Проверка файла package.json, содержащего список зависимостей проекта.
    2. Установка зависимостей:
        Выполнение команды npm install для установки зависимостей.
        Важно иметь установленный Node.js версии 14.17.
    3. Сборка проекта:
        Запуск сборки сервиса API с помощью команды npm run build, указав API.
        Использование Nest CLI для управления сборкой.
    4. Запуск сервиса:
        Запуск скомпилированного файла main.js из директории dist с помощью Node.js.
    5. Создание Dockerfile:
        Определение базового образа (Node.js с версией 14 на основе Alpine, например).
        Установка рабочей директории (например, /opt/app).
        Копирование всего проекта в контейнер.
        Установка зависимостей проекта внутри контейнера.
        Сборка проекта внутри контейнера.
        Указание команды для запуска сервиса при старте контейнера (CMD node dist/apps/api/main.js).
    6. Сборка и запуск контейнера:
        Использование команды docker build с указанием пути к Dockerfile и контекста сборки.
        Запуск контейнера из собранного образа с помощью команды docker run.


4.5. Улучшаем сборку

    1. Проблема размера и кэширования
        Исходный образ весит 1.2 ГБ, что много для Node.js приложения.
        Неэффективное кэширование: при изменении кода без изменения зависимостей требуется повторная установка зависимостей.
    2. Оптимизация кэширования
        Проблема: При любом изменении кода, повторно запускается установка зависимостей (npm install), что забирает много времени.
        Решение: Разделить добавление зависимостей и кода.
            Сначала копируем только файлы package.json и package-lock.json (или любые другие файлы, содержащие зависимости).
            Запускаем npm install.
            После этого добавляем оставшийся код.
            Это позволяет использовать кэш для слоя с зависимостями, если сами зависимости не изменились.
    3. Выбор более оптимального базового образа
        Изначально использовался стандартный образ Node 14.
        Решение: Переход на образ Node 14 Alpine.
            Alpine Linux имеет меньший размер по сравнению с другими версиями, что сокращает итоговый размер образа.
    4. Результаты оптимизации
        Размер исходного образа уменьшился с 1.2 ГБ до 467 МБ.
        Улучшенное кэширование позволяет избежать повторной установки зависимостей при каждом изменении кода, что существенно сокращает время сборки образа.
    5. Практические действия по оптимизации
        Изменение Dockerfile для копирования только файлов с зависимостями перед установкой.
        Использование образа Node 14 Alpine в качестве базы.
        Демонстрация процесса сборки с улучшенным кэшированием и проверка окончательного размера образа.


4.6. Анализируем image

Введение:

    Цель урока: Анализ и оптимизация Docker имиджей.
    Инструмент анализа: Утилита Dive (находится в бета-версии).

Установка Dive:

    Система: Ubuntu.
    Команда установки: (предполагается, что будет показана конкретная команда).
    Ввод пароля пользователя для установки.

Использование Dive:

    Запуск анализа: dive [имя_имиджа] (например, dive test:latest).
    Поведение: Dive анализирует слои и файловую систему имиджа, строит граф изменений.

Анализ результата:

    Интерфейс Dive позволяет просмотреть каждый слой имиджа.
    Можно увидеть добавленные файлы и директории на каждом этапе.
    Возможность оценить "неиспользованное пространство" и эффективность имиджа.

Практический анализ:

    Пример анализа файловой системы: от добавления package.json до выполнения npm install.
    Идентификация излишеств: например, исходные коды и конфигурационные файлы, не нужные в продакшене.

Оптимизация:

    Multistage build позволяет сократить размер имиджа, оставив лишь необходимое для работы приложения.
    В примере ожидается, что размер сократится с 472 мегабайт до 330 мегабайт.
    Утилита показывает потенциально неиспользуемые слои и позволяет определить, что можно удалить для оптимизации.


4.7. Многоэтапная сборка

Цели Лекции:

    Объяснить понятие и преимущества мультистейдж билда в Docker.
    Научиться уменьшать размер финального образа приложения.

Проблемы Существующего Подхода:

    Исходный код и неиспользуемые файлы сохраняются в финальном образе.
    Установлены и разработческие, и продакшн зависимости.

Решение: Мультистейдж Билд

    Первая Стадия: Сборка
        Используем базовый образ (node alpine) для создания сборки.
        Установка всех зависимостей, включая разработческие.
        Сборка приложения и его исходного кода.
    Вторая Стадия: Оптимизация
        Снова используем базовый образ (node alpine) для создания чистого, оптимизированного образа.
        Копирование только необходимых файлов: package.json и сборки приложения (dist).
        Установка только продакшн зависимостей.

Преимущества:

    Уменьшение размера финального образа до 339 мегабайт.
    В финальном имидже остаются только необходимые для запуска файлы и зависимости.
    Улучшенная безопасность: секреты и ненужные файлы не попадают в продакшн образ.

Применение Мультистейдж Билда:

    Процесс состоит из двух этапов: сборка и оптимизация.
    Второй этап позволяет избавиться от лишних файлов и зависимостей, оставляя только то, что необходимо для работы приложения.


4.8. Упражнение - Сборка go проекта

Цель упражнения

    Научиться создавать двухфазный билд Docker образа для Go-приложения.
    Уменьшить размер финального имиджа, используя Scratch как базовый образ.

Шаги выполнения

    Подготовка
        Скачивание проекта с GitHub (https://github.com/AlariCode/docker-demo-2)
        Создание Dockerfile
    Первая фаза: Сборка Go-приложения
        Базовый образ: golang:alpine (небольшой размер, содержит необходимые инструменты для сборки Go-приложений)
        Копирование кода в контейнер
        Сборка Go-приложения в бинарный файл с параметрами для Linux архитектуры
    Вторая фаза: Создание финального образа
        Базовый образ: Scratch (пустой образ)
        Копирование собранного бинарного файла из первой фазы
        Указание бинарного файла как точки входа (entry point)

Выполнение и результаты

    Сборка Docker образа командой docker build.
    Итоговый размер образа значительно меньше, чем если бы использовался базовый образ golang:alpine – на примере, получен образ размером всего 6.13MB.
    Запуск контейнера из собранного образа успешно.